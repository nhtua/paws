Think of the Executor not as an "AI," but as a **Virtual Machine** (like a Java VM or Game Engine) that reads a script (AOL) and strictly executes it step-by-step 1, 2\.

### 1\. Module: aol\_parser.py (The Loader)

This module acts as the "front-end" of your compiler. It reads the text file and converts it into a structured object the machine can understand. It does not execute code; it validates the schema.

* **load\_aol\_file(file\_path: str) \-\> WorkflowPlan**  
* Reads the raw .aol text file.  
* Parses the three mandatory sections: Provider, User Inputs, and Workflow Logic 3\.  
* Returns a structured WorkflowPlan object (a list of steps).  
* **validate\_dependencies(plan: WorkflowPlan) \-\> bool**  
* Checks Section 1 (Provider Description) to ensure all required tools (e.g., "ffmpeg", "ComfyUI") and credentials exist in the system before starting 3\.

### 2\. Module: state\_manager.py (The Memory)

This handles **Event Sourcing**. The Executor is stateless; this module ensures that if the system crashes, it can reload the log and resume exactly where it left off 4\.

* **initialize\_state(user\_inputs: dict) \-\> EventLog**  
* Creates a new append-only log.  
* Records "State Zero" using the inputs from AOL Section 2 5\.  
* **append\_event(event\_type: str, payload: dict) \-\> None**  
* Writes an action or observation to the permanent log (e.g., JSON file or database).  
* *Example:* append\_event("ACTION\_START", {"step": 1, "tool": "ffmpeg"}).  
* **get\_last\_successful\_step() \-\> int**  
* Reads the log to find the last step that emitted a "SUCCESS" event, allowing the Executor to skip already-completed steps upon a restart 4\.

### 3\. Module: mcp\_client.py (The Translation Layer)

This is the **Agent-Computer Interface (ACI)**. This module isolates the Executor from the messy details of CLI commands. It treats tools as "Black Boxes" via the **Model Context Protocol (MCP)** 6, 7\.

* **discover\_tools() \-\> dict**  
* Scans for available MCP servers (Extensions) and loads their capability schemas (e.g., knowing that the "ffmpeg" tool has a function called combine\_videos) 8\.  
* **send\_payload(tool\_name: str, function\_name: str, arguments: dict) \-\> ExecutionResult**  
* **The "Clean" Input:** Takes a high-level command (e.g., {"action": "convert", "file": "video.mp4"}).  
* **The Handoff:** Sends this JSON to the specific Tool's Python wrapper. The wrapper (external to this module) handles the binary translation (e.g., generating the ffmpeg \-i ... command) 6\.  
* **parse\_observation(raw\_output: str) \-\> dict**  
* Receives the raw standard output/error (stdout/stderr) from the tool.  
* Standardizes it into a clean JSON observation for the Event Log 9\.

### 4\. Module: security.py (The Jailer)

This enforces **Safety via Isolation**. It ensures the plan typically generated by an AI doesn't destroy the host machine 10\.

* **verify\_entitlements(tool\_name: str, target\_path: str) \-\> bool**  
* Checks if the tool is allowed to touch the requested file.  
* *Rule:* Tools should only have read/write access to specific asset folders (e.g., ./workspace/assets/), blocking access to root system files 11\.  
* **enforce\_resource\_limits(container\_id: str) \-\> None**  
* (Optional) If running tools in Docker, this ensures a tool doesn't consume 100% CPU or RAM, preventing "Shared Fate" failures 11\.

### 5\. Module: validator.py (The Critic)

This implements the **Evaluator-Optimizer** pattern. It checks if a step actually succeeded, rather than just assuming it did because the code didn't crash 12, 13\.

* **validate\_step(step\_output: dict, success\_criteria: dict) \-\> bool**  
* Performs "Semantic Checks."  
* *Example:* If the step was "Generate Image," this function checks: "Does the output file exist?" AND "Is the file size \> 0 bytes?" 12\.  
* **trigger\_feedback\_loop(error\_log: dict) \-\> NewPlan**  
* If validation fails, this prepares the data to send back to the Planner (LLM) to request a corrected AOL file 14\.

### 6\. Module: executor\_engine.py (The Main Loop)

This ties everything together using the **OODA Loop** (Observe-Orient-Decide-Act) 2, 15\.

* **run\_workflow(aol\_file: str)**  
* **Step 1:** Call aol\_parser.load\_aol\_file().  
* **Step 2:** Call state\_manager.initialize\_state().  
* **Step 3 (The Loop):** Iterate through the steps in the Plan.  
* **Observe:** state\_manager.get\_last\_successful\_step().  
* **Orient:** Determine the next pending step from the Plan.  
* **Decide:** security.verify\_entitlements().  
* **Act:** mcp\_client.send\_payload() \-\> Wait for parse\_observation().  
* **Verify:** validator.validate\_step().  
* **Log:** state\_manager.append\_event().


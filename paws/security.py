"""
Security - Entitlement Enforcement (The Jailer)

Enforces safety via isolation. Ensures the plan (typically generated by AI)
doesn't destroy the host machine by checking access rights before execution.
"""

import os
from pathlib import Path
from typing import List, Optional

from paws.core.models import AOLEntitlement


def verify_entitlements(
    entitlements: List[AOLEntitlement],
    extension_name: str,
    tool_name: str,
    target_path: Optional[str] = None
) -> tuple[bool, str]:
    """
    Check if the tool is allowed to perform the requested operation.
    
    Args:
        entitlements: List of entitlements from the provider section
        extension_name: Name of the extension being used
        tool_name: Name of the tool being called
        target_path: Optional path being accessed
        
    Returns:
        Tuple of (is_allowed, reason)
    """
    if not entitlements:
        # No entitlements defined = allow everything (permissive mode)
        return (True, "No entitlements defined - permissive mode")
    
    # Check for matching capability
    for entitlement in entitlements:
        if _matches_capability(entitlement.capability, extension_name, tool_name):
            # If path is specified, check scope
            if target_path:
                if _matches_scope(entitlement.scope, target_path):
                    return (True, f"Allowed by entitlement: {entitlement.scope}")
            else:
                # No path to check, capability match is sufficient
                return (True, f"Allowed by capability: {entitlement.capability}")
    
    return (False, f"No entitlement allows {extension_name}.{tool_name} on '{target_path or 'any path'}'")


def _matches_capability(capability: str, extension_name: str, tool_name: str) -> bool:
    """
    Check if an entitlement capability matches the extension/tool being used.
    
    Capabilities can be:
    - Extension name: "Bash" matches any Bash tool
    - Specific pattern: "Execute Bash Commands" matches Bash execute_command
    - Wildcard: "*" matches everything
    """
    cap_lower = capability.lower()
    ext_lower = extension_name.lower()
    
    # Exact extension match
    if cap_lower == ext_lower:
        return True
    
    # Wildcard
    if capability == "*":
        return True
    
    # Pattern matching (e.g., "Execute Bash Commands")
    if ext_lower in cap_lower:
        return True
    
    # Check for common patterns
    if ext_lower == "bash" and "bash command" in cap_lower:
        return True
    if ext_lower == "bash" and "execute" in cap_lower and "command" in cap_lower:
        return True
    
    return False


def _matches_scope(scope: str, target_path: str) -> bool:
    """
    Check if a path is within the allowed scope.
    
    Scopes can be:
    - "Read ./workspace/" - read access to workspace
    - "Read/Write ./workspace/" - read and write access
    - "Execute" - execution allowed (no path restriction)
    - "*" - all paths allowed
    """
    # Wildcard
    if scope == "*":
        return True
    
    # "Execute" scope doesn't restrict paths
    if scope.lower().startswith("execute"):
        return True
    
    # Extract path pattern from scope
    # e.g., "Read/Write ./workspace/" -> "./workspace/"
    scope_parts = scope.split()
    if len(scope_parts) < 2:
        return False
    
    scope_path = scope_parts[-1]
    
    # Normalize paths
    try:
        # Handle relative paths
        if scope_path.startswith("./"):
            scope_path = os.path.abspath(scope_path)
        if target_path.startswith("./"):
            target_path = os.path.abspath(target_path)
        
        # Check if target is within scope
        scope_resolved = Path(scope_path).resolve()
        target_resolved = Path(target_path).resolve()
        
        # Check if target is the same as or a child of scope
        try:
            target_resolved.relative_to(scope_resolved)
            return True
        except ValueError:
            return False
    except Exception:
        return False


def extract_paths_from_inputs(inputs: dict) -> List[str]:
    """
    Extract file paths from step inputs that should be checked against entitlements.
    
    Args:
        inputs: The inputs dict from a step
        
    Returns:
        List of paths found in inputs
    """
    paths = []
    
    # Keys that contain commands, not paths
    command_keys = {"command", "script", "code", "shell", "cmd"}
    
    def _extract_recursive(value, key=""):
        # Skip command-like keys - they contain shell commands, not paths to check
        if key.lower() in command_keys:
            return
        
        if isinstance(value, str):
            # Better path detection heuristics:
            # - Starts with /, ./, ~/, or is a Windows path
            # - Not a URL
            # - Not a shell command (contains pipes, redirects, etc.)
            value_stripped = value.strip()
            
            # Skip URLs
            if value_stripped.startswith(("http://", "https://", "ftp://")):
                return
            
            # Skip things that look like shell commands
            shell_indicators = ["|", "&&", "||", ";", ">", "<", "`", "$("]
            if any(ind in value_stripped for ind in shell_indicators):
                return
            
            # Check if it looks like a path
            is_path = (
                value_stripped.startswith("/") or
                value_stripped.startswith("./") or
                value_stripped.startswith("../") or
                value_stripped.startswith("~/") or
                (len(value_stripped) > 2 and value_stripped[1] == ":" and value_stripped[2] == "\\")  # Windows
            )
            
            if is_path:
                paths.append(value_stripped)
                
        elif isinstance(value, dict):
            for k, v in value.items():
                _extract_recursive(v, k)
        elif isinstance(value, list):
            for item in value:
                _extract_recursive(item)
    
    _extract_recursive(inputs)
    return paths

